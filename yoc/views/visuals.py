__author__ = 'aakh'

import logging, json
import calendar
from dateutil.relativedelta import relativedelta
from datetime import datetime
logger = logging.getLogger(__name__)

from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.db.models import Q
from yoccore import models
import validations

@login_required
def get_session_serie(request):
    template = 'yoccore/vis.html'
    context = {}

    __acceptable_step_sizes = ['D']




class TimeDependentGraph(object):
    """
        Class which holds static methods and data for generating
        NVD3-compatible data for feedback against time.

        Parameters for x axis are set at point of instantiation, you can then
        run methods to generate y series. All data is stored against the class.

    """

    __acceptable_step_sizes = ['D', 'M'] # Daily, Monthly

    def __init__(self, start_date, end_date=datetime.now(), step_size='D'):
        """
        Pick the date-times you want the x axis to start and end with and the
        size of bins desired. If you wish to redefine the x axis then
        instantiate a new object.

        Once instantiated the y series can be
        generated by running any other methods on this class. All data is
        stored against the class is self.x_series and self.y_series.

        :param start_date: a datetime object
        :param end_date: a datetime object
        :param step_size: a string, must be supported in
        self.acceptable_step_sizes
        :return:
        """

        assert(step_size in self.__acceptable_step_sizes)

        # store
        self.__start_date = start_date
        self.__end_date = end_date
        self.__step_size = step_size

        # initialise
        self.x_series = []  # just a list of datetime objects
        self.x_series_utc = []  # just a list of ints for utc timestamp in ms
        self.y_series = []
        self.y_series_c = []
        # Template for y_series:
        # [{
        #     'cumulative': bool,
        #     'data': [numbers],
        #     'name': string
        # },..]

        # build x series to output
        self.__create_x_series()

        # just pull from the DB once and then use the result for further queries
        self.answer_source = models.Answer.objects.all
        self.cleaned_source = models.CleanedAnswer.objects.all
        self.session_source = models.Session.objects.all

    def __create_x_series(self):
        """
        Generates the x axis data and writes to self.x_series, based on
        self.start_date, self.end_date and step_size.

        :return:
        """

        # initial values
        current_step = self.__start_date

        # continue up until (and including) the end_date
        while current_step.date() < self.__end_date.date():
            # date accuracy is enough
            # data points are stored as datetime, edit here if this changes
            self.x_series.append(current_step)
            self.x_series_utc.append(calendar.timegm( current_step.utctimetuple() * 1000 ))

            # if days
            if self.__step_size == 'D':
                current_step = current_step + relativedelta(days=1)

            # if months
            elif self.__step_size == 'M':
                current_step = current_step + relativedelta(months=1)

    def filtered_datum(self, desired_series, seriesQ):

        if desired_series in ['age', 'gender']:
            answers = list(models.Answer.objects.filter(seriesQ['series']).exclude(question__question_type__iexact='PD'))
            yoc_sessions = [a.session for a in answers]
            cleaned_answers = models.CleanedAnswer.objects.filter(answer__in=answers, not_feedback=False)

        elif desired_series == 'topic':
            cleaned_answers = models.CleanedAnswer.objects.filter(not_feedback=False).filter(seriesQ['series'])

            answers1 = models.Answer.objects.filter(id__in=cleaned_answers.values_list('answer', flat=True))
            # and get Answer objects where get_topic evaluates to the desired criteria
            answers2 = filter(lambda x: x.get_topic(*cleaned_answers) in zip(*seriesQ['series'].children)[1],
                              models.Answer.objects.exclude(id__in=cleaned_answers.values_list('answer', flat=True)))

            answers = list(set(list(answers1)+list(answers2)))
            yoc_sessions = [a.session_id for a in answers]


        elif desired_series == 'branch':
            yoc_sessions = models.Session.objects.filter(seriesQ['series'])
            answers = models.Answer.objects.filter(session__in=yoc_sessions)
            cleaned_answers = models.CleanedAnswer.objects.filter(answer__in=answers, not_feedback=False)

        else:
            yoc_sessions = models.Session.objects.all()
            answers = models.Answer.objects.all()
            cleaned_answers = models.CleanedAnswer.objects.all()

        return {'yoc_sessions':list(yoc_sessions), 'answers':list(answers), 'cleaned_answers':list(cleaned_answers)}

    def __create_new_y_series(self, desired_series, name, **seriesQ):
        """
        Creates two y_series (a cumulative and non_cumulative) count of
        feedback over time for the given set of filters.

        Outputs to self.y_series.

        :param name: name of the series
        :param seriesQ: args of django Q filters to apply to Feedback count
        :return:
        """

        # initialise
        # Non-cumulative
        count_series_nc = [0]
        avg_series_nc = [0]
        tot_series_nc = [0]


        # Cumulative
        count_series_c = [0]
        avg_series_c = [0]
        tot_series_c = [0]

        # get answers, cleaned_answers and session data for the desired series eg gender = Male
        datum = self.filtered_datum(desired_series, seriesQ)

        #apply series level filters
        try:
            datum['yoc_sessions'] = filter(lambda x: x.location in zip(*seriesQ['sessionQ'].children)[1],
                                       datum['yoc_sessions'])
        except:
            logger.debug("seriesQ['sessionQ'] is empty")

        try:
            datum['cleaned_answers'] = filter(lambda x: x.topic() in zip(*seriesQ['cleanedQ'].children)[1],
                                       datum['cleaned_answers'])
        except:
            logger.debug("seriesQ['cleanedQ'] is empty")

        try:
            datum['answers'] = filter(lambda x: x.answer_text in zip(*seriesQ['answersQ'].children)[1],
                                       datum['answers'])
        except:
            logger.debug("seriesQ['answersQ'] is empty")


        try:
            datum['answers'] = filter(lambda x: x.get_topic(*datum['cleaned_answers']) in zip(*seriesQ['cleanedQ'].children)[1],
                                       datum['answers'])
        except:
            logger.debug("seriesQ['cleanedQ'] is empty (topic filter)")

        # start at 0, could start with all feedback before start but this could
        #  give very erroneous looking data if trying to crop into a data-set
        for i, upper in enumerate(self.x_series[1:]):
            # upper will be the top of the bin (exclusive)
            # lower will be the bottom of the bin (inclusive)
            lower = self.x_series[i]

            datum_capped = filter(lambda x: x.session.submit_date < upper.date(), datum['answers'])
            cleaned_datum_capped = filter(lambda x: x.answer.session.submit_date < upper.date(), datum['cleaned_answers'])

            datum_bounded = filter(lambda x: x.session.submit_date >= lower.date(), datum_capped)
            cleaned_datum_bounded = filter(lambda x: x.answer.session.submit_date >= lower.date(), cleaned_datum_capped)

            logger.info('passing count')
            # Just count the feedback that this applies to
            count_series_nc.append(len(datum_bounded))

            logger.info('passing average')
            data_to_average = [x.get_rating(*cleaned_datum_bounded) for x in datum_bounded]
            avg_series_nc.append(validations.Numbers.average_list(data_to_average))

            logger.info('passing total')
            # data_to_sum = [x.get_rating(*cleaned_datum_bounded) for x in datum_bounded]
            tot_series_nc.append(validations.Numbers.sum_list(data_to_average))

            count_series_c.append(sum(count_series_nc))
            avg_series_c.append(sum(avg_series_nc))
            tot_series_c.append(sum(tot_series_nc))

        # Once we reach this point our series is complete

        y_series_c = {
            'cumulative': True,
            'data': count_series_c, # todo: add different series types
            'name': "%s (cumulative)" % name
        }

        y_series_nc = {
            'cumulative': False,
            'data': count_series_nc,
            'name': "%s (non-cumulative)" % name
        }

        # append to output
        self.y_series_c.append({y_series_c['name']:y_series_c['data']})
        self.y_series.append({y_series_nc['name']:y_series_nc['data']})

    def create_y_series(self, outcome='count', desired_series='total', **desired_filters):
        """

        :param outcome: count, average,

        :param desired_series: demographic, topic, branch. If missing, then ignored

        :param fixed_filters: dictionary of filters to apply to this chart If missing, take TOTAL
            KEYS: age, gender, branch, topic
        :return:
        """

        answersQ = Q()
        cleanedQ = Q()
        sessionQ = Q()
        self.y_series = []

        valid_outcomes = ['count', 'average',]

        valid_filters = {
            'age':answersQ,
            'gender':answersQ,
            'branch':sessionQ,
            'topic':cleanedQ
        }

        series_lists = {
            'age': ('>55','46-55','26-35','<18','36-45','18-25',),
            'gender':('Male', 'Female'),
            'topic':zip(*models.CleanedAnswer.topics)[0],
            'branch':zip(*models.Session.locations)[0],
            'total':('total',)
        }

        if outcome not in valid_outcomes:
            outcome = 'count'

        if desired_series not in series_lists.keys():
            desired_series = 'total'

        for f in desired_filters.keys():
            if f not in valid_filters.keys():
                desired_filters.pop(f)
                logger.info('removing filter %s'%f)

        #build filters
        for f,v in desired_filters.iteritems():

            if not isinstance(v, (list,tuple)): v = list(v)
            else: v = list(set(v))

            if f in ['age', 'gender']:
                for vi in v: valid_filters[f].add(Q(answer_text=str(vi)), Q.OR)

            elif f == 'topic':
                for vi in v: valid_filters[f].add(Q(topic=str(vi)), Q.OR)

            elif f == 'branch':
                for vi in v: valid_filters[f].add(Q(location=str(vi)), Q.OR)

        filters = {'answersQ':answersQ,
                   'cleanedQ': cleanedQ,
                   'sessionQ': sessionQ}

        for ser in series_lists[desired_series]:
            if desired_series in ['age', 'gender']:
                q = Q(answer_text=str(ser))

            elif desired_series == 'topic':
                q = Q(topic=str(ser))

            elif desired_series == 'branch':
                q = Q(location=str(ser))

            else:
                q = Q()

            filters.update({'series':q})
            self.__create_new_y_series(desired_series=desired_series, name=ser, **filters)
            filters.pop('series')

        # return {
        #     'x': self.x_series,
        #     'y': self.y_series,
        #     'y_c': self.y_series_c
        # }

    def get_data(self, outcome, x_utc=True, include_cumulatives=False):

        return {
            'x': self.x_series_utc if x_utc else self.x_series,
            'y': self.y_series,
            'y_c': self.y_series_c if include_cumulatives else None
        }