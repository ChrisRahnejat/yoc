__author__ = 'aakh'

import logging, json
from dateutil.relativedelta import relativedelta
from datetime import datetime
logger = logging.getLogger(__name__)

from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.db.models import Q

from yoccore import models

@login_required
def get_session_serie(request):
    template = 'yoccore/vis.html'
    context = {}

    __acceptable_step_sizes = ['D']




class TimeDependentGraph(object):
    """
        Class which holds static methods and data for generating
        NVD3-compatible data for feedback against time.

        Parameters for x axis are set at point of instantiation, you can then
        run methods to generate y series. All data is stored against the class.

    """

    __acceptable_step_sizes = ['D', 'M'] # Daily, Monthly

    def __init__(self, start_date, end_date=datetime.now(), step_size='D'):
        """
        Pick the date-times you want the x axis to start and end with and the
        size of bins desired. If you wish to redefine the x axis then
        instantiate a new object.

        Once instantiated the y series can be
        generated by running any other methods on this class. All data is
        stored against the class is self.x_series and self.y_series.

        :param start_date: a datetime object
        :param end_date: a datetime object
        :param step_size: a string, must be supported in
        self.acceptable_step_sizes
        :return:
        """

        assert(step_size in self.__acceptable_step_sizes)

        # store
        self.__start_date = start_date
        self.__end_date = end_date
        self.__step_size = step_size

        # initialise
        self.x_series = []  # just a list of datetime objects
        self.y_series = []
        # Template for y_series:
        # [{
        #     'cumulative': bool,
        #     'data': [numbers],
        #     'name': string
        # },..]

        # build x series to output
        self.__create_x_series()

        # just pull from the DB once and then use the result for further queries
        self.answer_source = models.Answer.objects.all
        self.cleaned_source = models.CleanedAnswer.objects.all
        self.session_source = models.Session.objects.all

    def __create_x_series(self):
        """
        Generates the x axis data and writes to self.x_series, based on
        self.start_date, self.end_date and step_size.

        :return:
        """

        # initial values
        current_step = self.__start_date

        # continue up until (and including) the end_date
        while current_step.date() < self.__end_date.date():
            # date accuracy is enough
            # data points are stored as datetime, edit here if this changes
            self.x_series.append(current_step)

            # if days
            if self.__step_size == 'D':
                current_step = current_step + relativedelta(days=1)

            # if months
            elif self.__step_size == 'M':
                current_step = current_step + relativedelta(months=1)

    def __create_new_y_series(self, desired_series, name, outcome='count', **seriesQ):
        """
        Creates two y_series (a cumulative and non_cumulative) count of
        feedback over time for the given set of filters.

        Outputs to self.y_series.

        :param name: name of the series
        :param seriesQ: args of django Q filters to apply to Feedback count
        :return:
        """

        # initialise
        # Non-cumulative
        this_series_nc = [0]
        sources = []

        # Cumulative
        this_series_c = [0]

        # filters = {'answersQ':answersQ,
        #            'cleanedQ': cleanedQ,
        #            'sessionQ': sessionQ}

        if desired_series in ['age', 'gender']:
            yoc_sessions = models.Answer.objects.filter(seriesQ['series']).values_list('session_id', flat=True)
            answers = models.Answer.objects.filter(session__id__in=
                                                   yoc_sessions).exclude(question__question_type__iexact='PD')
            cleaned_answers = models.CleanedAnswer.objects.filter(answer__in=answers)

        elif desired_series == 'topic':
            cleaned_answers = models.CleanedAnswer.objects.filter(seriesQ['series'])
            answers = models.Answer.objects.filter(id__in=cleaned_answers.values_list('answer', flat=True))
            # todo: and get Answer objects where get_topic evaluates to the desired criteria
            # answers = filter(lambda x: x.get_topic()=seriesQ['series'], all_answers)
            yoc_sessions = answers.values_list('session_id', flat=True)


        elif desired_series == 'branch':
            yoc_sessions = models.Session.filter(seriesQ['series'])

        for q in seriesQ:pass #todo: add other filters onto the querysets created above [or the lists]

        # start at 0, could start with all feedback before start but this could
        #  give very erroneous looking data if trying to crop into a data-set

        for i, upper in enumerate(self.x_series[1:]):
            # upper will be the top of the bin (exclusive)
            # lower will be the bottom of the bin (inclusive)
            lower = self.x_series[i]

            # build the filters to apply to Feedback to find feedback in bin
            this_filter = Q()

            # add any additional filters that were passed in
            for Qs in seriesQ:
                this_filter.add(Qs, Q.AND)

            # very important to use submit and not created or last updated otherwise
            # we'll have the wrong stuff!
            if name == 'Session':
                this_filter.add(Q(submit_date__lte=upper), Q.AND)
                this_filter.add(Q(submit_date__gt=lower), Q.AND)
                sources.append(self.session_source)

            else:
                # if name == 'Answer':
                this_filter.add(Q(session__submit_date__lte=upper), Q.AND)
                this_filter.add(Q(session__submit_date__gt=lower), Q.AND)
                sources.append(self.answer_source)

                # if name == 'CleanedAnswer':
                this_filter.add(Q(answer__session__submit_date__lte=upper), Q.AND)
                this_filter.add(Q(answer__session__submit_date__gt=lower), Q.AND)
                sources.append(self.cleaned_source)


            # Just count the feedback that this applies to
            if outcome == 'count':
                ctr = 0
                try:
                    for source in sources: ctr += source.filter(this_filter).count()
                except Exception, e:
                    logger.error(e.message)
                    return False

            elif outcome == 'average':
                logger.info('passing average')
                pass

            # The count is the new y value for this series
            this_series_nc.append(ctr)

            # total count is the new value for the cumulative (includes new
            # value)
            this_series_c.append(sum(this_series_nc))

        # Once we reach this point our series is complete

        y_series_c = {
            'cumulative': True,
            'data': this_series_c,
            'name': "%s (cumulative)" % name
        }

        y_series_nc = {
            'cumulative': False,
            'data': this_series_nc,
            'name': "%s (non-cumulative)" % name
        }

        # append to output
        self.y_series.append(y_series_c)
        self.y_series.append(y_series_nc)

    def create_y_series(self, outcome='count', desired_series='total', **desired_filters):
        """

        :param outcome: count, average,

        :param desired_series: demographic, topic, branch. If missing, then ignored

        :param fixed_filters: dictionary of filters to apply to this chart If missing, take TOTAL
            KEYS: age, gender, branch, topic
        :return:
        """

        answersQ = Q()
        cleanedQ = Q()
        sessionQ = Q()
        self.y_series = []

        valid_outcomes = ['count', 'average',]

        valid_filters = {
            'age':answersQ,
            'gender':answersQ,
            'branch':sessionQ,
            'topic':cleanedQ
        }

        series_lists = {
            'age': ('>55','46-55','26-35','<18','36-45','18-25',),
            'gender':('Male', 'Female'),
            'topic':zip(*models.CleanedAnswer.topics)[0],
            'branch':zip(*models.Session.locations)[0],
            'total':('total',)
        }

        if outcome not in valid_outcomes:
            outcome = 'count'

        if desired_series not in series_lists.keys():
            desired_series = 'total'

        for f in desired_filters.keys():
            if f not in valid_filters.keys():
                desired_filters.pop(f)
                logger.info('removing filter %s'%f)

        #build filters
        for f,v in desired_filters.iteritems():

            if not isinstance(v, (list,tuple)): v = list(v)
            else: v = list(set(v))

            if f in ['age', 'gender']:
                for vi in v: valid_filters[f].add(Q(answer_text=str(vi)), Q.OR)

            elif f == 'topic':
                for vi in v: valid_filters[f].add(Q(topic=str(vi)), Q.OR)

            elif f == 'branch':
                for vi in v: valid_filters[f].add(Q(location=str(vi)), Q.OR)

        filters = {'answersQ':answersQ,
                   'cleanedQ': cleanedQ,
                   'sessionQ': sessionQ}

        for ser in series_lists[desired_series]:
            if desired_series in ['age', 'gender']:
                q = Q(answer_text=str(ser))

            elif desired_series == 'topic':
                q = Q(topic=str(ser))

            elif desired_series == 'branch':
                q = Q(location=str(ser))

            else:
                q = Q()

            filters.update({'series':q})
            self.__create_new_y_series(desired_series=desired_series, name=ser, outcome, **filters)
            filters.pop('series')

        return {
            'x': self.x_series,
            'y': self.y_series
        }